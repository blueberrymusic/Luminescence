
<!DOCTYPE html>
<html>
<head>
	<title>Help for Andrew's Digital Loom</title>

<!-- jQuery must follow my style and precede Bootstrap -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<!-- Bootstrap stuff -->
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css" integrity="sha384-aUGj/X2zp5rLCbBxumKTCw2Z50WgIr1vs/PFN4praOTvYXWlVyh2UtNUU0KAUhAX" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js" integrity="sha512-K1qjQ+NcF2TYO/eI3M6v8EiNYZfA95pQumfvcVrTHtwQVDG+aHRqLi/ETn2uB+1JqwYqVG3LIvdm9lj6imS/pQ==" crossorigin="anonymous"></script>

<!-- make mobile-friendly: http://www.w3schools.com/bootstrap/bootstrap_get_started.asp
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Just for grins, use Ubuntu here and there -->
<link href="http://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">

<link rel="stylesheet" type="text/css" href="help.css">
</head>

<body>

	<div class="container">
		<div class="row">
			<div class="col-md-10 col-md-offset-1">

				<div class="page-header">
<h1>Andrew's Digital Loom Help <small>Improved and Online!</small> </h1>


<p>
This is a quick-start guide to my online
<a href="http://www.TK">Digital Loom</a>.
Here's a shortcut to the
<a href="#commands">commands summary</a>.
</p>

<p>
The Digital Loom is a simplified and abstracted version
of a real loom used for weaving cloth.
You can set up the loom using patterns published in weaving
books that are over 100 years old,
or you can cook up crazy new designs of your own.
</p>

<p>
This document moves quickly.
For more information on everything, 
take a look at the 
<a href="#furtherReading">Further Reading</a>
section.
</p>

<p><a name='quickStart'></a></p>
<h2>Super-Quick Start</h2>
<p>
Click on the <em>Load Draft</em> button
near the top-middle of the screen and 
take a look at the built-in presets.
Don't bother clicking on the grids or
the fabric on the right,
because they're not interactive.
Instead, you can change the fabric size
using the text box above the fabric,
or change the pattern of the fabric
by altering what's in any of the five text boxes
on the left (and then pressing the arrow
to that box's right).
Start by changing colors (you can probably
guess at some reasonable color names for now),
and try fiddling with some of the numbers.
For now, keep all of your numbers in the range 0 to 7,
but you'll probably still get crazy results!
In the sections below you'll come to know
everything that's going on here.
</p>


<p><a name='toc'></a></p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#quickStart">Quick Start</a></li>
<li><a href="#toc">Table of Contents</a></li>
<li><a href="#overview">Overview of The Digital Loom</a></li>
<li><a href="#rightSide">The Right Side: The Draft</a></li>
<li><a href="#bridge">The Bridge: Patterns</a></li>
<li><a href="#leftSide">The Left Side: AWL Input (and Output)</a></li>
<li><a href="#makingPatterns">Making Patterns: The AWL Language</a></li>
<li><a href="#concepts">AWL Concepts</a></li>
<li><a href="#commands">The AWL Commands</a></li>
<li><a href="#notes">Notes on This Version of AWL</a></li>
<li><a href="#interface">The Rest of the Interface</a></li>
<li><a href="#colors">Colors</a></li>
<li><a href="#faq">FAQ</a></li>
<li><a href="#furtherReading">Further Reading</a></li>
</ul>

<p><a name='overview'></a></p>
<h2>Overview of The Digital Loom</h2>

<figure class="figure ">
  <img src="http://placehold.it/600x400" class="img-rounded center-block" alt="A generic square placeholder image with rounded corners in a figure.">
  <figcaption class="figure-caption text-center">
Figure 1: The Digital Loom with major sections labeled.
</figcaption>
</figure>

<p>
Figure 1 shows the Digital Loom,
with the major components labeled.
To create a piece of woven fabric,
you type expressions in the AWL language
(described below) into the five input
boxes on the left.
After you've typed an expression in one of
the boxes,
press the arrow to its right to copy the
results onto the right side of the window.
</p>

<p>
In this document I'll use very casual language
for the loom and its components;
see the references in the
<a href="#furtherReading">Further Reading</a>
section for more careful descriptions of the 
loom's elements and their names.
</p>

<p><a name='rightSide'></a></p>
<h2>The Right Side: The Draft</h2>

<p>
The right side of the window is 
collectively called the <strong>draft</strong>.
This shows you the results of your AWL
expressions,
and the final fabric that results.
The fabric is automatically re-woven each
time you change one of the input expressions.
The draft is not interactive:
clicking on the draft and fabric has no effect.
</p>
<p>
Think of the fabric as a grid.
We want to know the color of each cell
in that grid.
To find it,
we look at the three checkerboards
below and to the right of the grid,
and the row and column of colors 
just outside them.
</p>
<p>
The checkerboard on the right is
called the <strong>weft</strong>.
Each row of the weft is white except for
exactly one black square.
To the right of the weft is a column
of colors,
collectively called the <strong>weft colors</strong>.
Imagine that each cell in the weft colors
array is the source of a thread of colored
yarn that runs to the left pefectly horizontally,
passing through each cell of the fabric to its left.
</p>
<p>
The checkerboard below the fabric
called the <strong>warp</strong>.
Each column of the warp is white except for
exactly one black square.
Below the warp is a row
of colors,
collectively called the <strong>warp colors</strong>.
Imagine that each cell in the warp colors
array is the source of a thread of colored
yarn that runs vertically upwards,
passing through each cell of the fabric above it.
</p>
<p>
Thus each cell in the fabric has two threads
passing through it.
One of these threads will be on top, while
the other passes under it.
The cell will have the color of the thread on top.
To determine which thread is on top,
we use one more checkerboard.
</p>
<p>
The checkerboard below and to the right of
the fabric is called the <strong>tie-up</strong>.
Unlike the warp and weft,
the tie-up can have any arrangement of white
and black cells
(it can even be all white or all black,
though that would make a pretty boring fabric).
</p>
<p>
To determine which thread is on top of any given
cell in the fabric,
we follow a simple process,
illustrated in Figure 2:
</p>

<figure class="figure ">
  <img src="http://placehold.it/600x400" class="img-rounded center-block" alt="A generic square placeholder image with rounded corners in a figure.">
  <figcaption class="figure-caption text-center">
Figure 2: Finding the color of a cell in the fabric.
</figcaption>
</figure>

<ol>
<li>Look directly to the right, and find the black
cell in the weft for this row.</li>
<li>Look directly below, and find the black cell
in the warp for this column.</li>
<li>Look below the black weft cell, and to the
right of the black warp cell, to find a cell
in the tie-up. If that cell is black, the
warp thread is on top. Otherwise, the weft 
thread is on top.
</ol>

<p>
Although it's easy to state,
understanding how the warp, weft, and tie-up interact
to produce a design is anything but obvious!
You'll find that as you experiment with these three grids,
your intuition will grow,
and you'll get better at predicting what a particular
type of change will do to your design.
But part of the pleasure of having a digital loom at your
disposal is that it's easy to experiment,
and experiment again!
Just play and have fun,
and see what you can discover.
</p>
<p>
But if you can't click on the draft,
how do you set it up?
The answer is that the draft is created as a result
of the expressions you type into the input boxes
on the left hand side;
we'll turn to those now.
</p>

<p><a name='bridge'></a></p>
<h2>The Bridge: Patterns</h2>

<p>
The trick to describing a draft is to 
fill in the black and white squares the
way you want.
The historical way to to do this is to
use patterns of numbers.
We use this tradition here, 
as it allows you to immediately use any
of the countless drafts that have been
collected and published,
and it lets you communicate with other weavers.
</p>

<p>
Each of the five elements of the draft
gets filled in with its own pattern.
The three checkerboards use lists of numbers,
while the two colors sources use lists
of colors.
Each of these five grids has a slightly
different rule for how you convert its list
to grid contents,
so we'll cover each one.
In all cases,
we start counting at 0.
</p>

<p>
First, the weft: the checkerboard immediately
to the right of the fabric.
As we saw above,
the weaving process depends on
each row of the weft having exactly one black square.
So we can describe the weft by simply identifying
the location of that square in each row.
We do this by starting at the <strong>bottom</strong>
of the weft checkerboard,
and working our way up.
As we read each number from our list,
we count starting at the <strong>left</strong>
and going right.
Look at the weft grid in Figure 3a.
If the leftmost cell is black, we'd write 
that as 0.
If the cell to its right is black, 
that's a 1, and so on.
So on the bottom row, we'd write 2.
The next row up we'd write 1,
then 3, then 0.
The pattern then repeats after that.
So this weft is described by the 
sequence 2  1 3 0.
</p>

<figure class="figure ">
  <img src="http://placehold.it/600x400" class="img-rounded center-block" alt="A generic square placeholder image with rounded corners in a figure.">
  <figcaption class="figure-caption text-center">
Figure 3: Two drafts. See the text for the
lists that describe them.
</figcaption>
</figure>

<p>
Let's now look at the warp in Figure 3a.
Recall the each column of the warp is white
except for one black cell,
so again we only need to know the location
of that cell.
For the warp, we start at the
<strong>right</strong> and work our way
to the left,
and we count from the <strong>top</strong>
and go down.
So if the black cell is in the topmost row,
we'd call it 0.
If it's one down from that,
we'd call it a 1, 
and so on.
The warp pattern in Figure 3a is
then 4 3 2 1 0
which repeats forever
(note that the warp has 5 rows, while
the weft has only 4;
this is perfectly fine).
</p>
<p>
The colors are easy.
For both the warp and the weft,
we simply make a list of the colors
and repeat that list as needed.
Much of the time we'll use a very
simple list with just one color,
so all the thread will be that color.
In Figure 3a,
the list for the weft colors
is just <em>red</em>,
and the list for the warp colors 
is just <em>white</em>.
</p>
<p>
Finally, the tie-up.
Since the tie-up can have any arrangement
of black and while cells,
we just read them off starting at the
top left,
then moving to the right,
and then down a row,
like reading a book.
White cells are 1, and black cells are 0.
So in Figure 3a,
the first row of the tie-up is 0 0 1 1,
the second row is 0 1 1 0,
and so on.
Combining all the rows one after the other
gives us a list of (in this case) 20 
0's and 1's.
TK Replace the numbers above and those in the
list below  with actual values from the figure
</p>
<p>
To summarize, the following list completely
summarizes the draft in Figure 3a,
and thus also completely specifies the pattern
of the fabric it leads to.
If you want to share your draft with other weavers,
this is all you need to give them,
and it's all you need to know from them to
recreate their drafts on your own loom.
</p>
<ul>
<li><strong>Warp pattern:</strong> TK 0 3 2 1 5 2 </li>
<li><strong>Weft pattern:</strong> TK 0 3 2 1 5 2 </li>
<li><strong>Warp colors:</strong> TK red </li>
<li><strong>Weft colors:</strong> TK yellow blue </li>
<li><strong>Tie-up:</strong> TK 1 1 0 0 0 0 0 1 1 0 </li>
</ul>
<p>
Figure 3b offers another draft.
Try to write down the five lists that
describe the five sections of the draft
before you read the list below:
</p>
<ul>
<li><strong>Warp pattern:</strong> TK 0 3 2 1 5 2 </li>
<li><strong>Weft pattern:</strong> TK 0 3 2 1 5 2 </li>
<li><strong>Warp colors:</strong> TK red </li>
<li><strong>Weft colors:</strong> TK yellow blue </li>
<li><strong>Tie-up:</strong> TK 1 1 0 0 0 0 0 1 1 0 </li>
</ul>
<p>
When we weave the fabric,
we just repeat the warp and weft
patterns and colors as needed.
The tie-up we only have to make once,
but if the input pattern is shorter than
the size of the tie-up grid,
we just use the input pattern over and over until
the grid is filled up,
as in the last example.
</p>
<p>
Now that we know how lists of numbers
let us build a draft,
we'll see how to easily
make big lists of numbers that
lead to beautiful fabrics.
</p>

<p><a name='leftSide'></a></p>
<h2>The Left Side: AWL Input (and Output)</h2>

<p>
The job of the left side of the window
is to make patterns of numbers and colors.
The problem will use these
to fill in the draft.
</p>
<p>
There are five text input boxes,
one for each of the five sections of the draft.
You can type an expression in a special pattern-making
language into each box,
and then press the arrow to the right of the box
to translate your expression into a list.
The list is immediately copied into the draft
(that is, the grids are updated)
and the fabric is immediately re-woven.
</p>
<p>
It's often useful to see the output of your expressions
so you can make sure you're creating the pattern you want.
At the bottom of the left side there's a region that
holds the output of any one of the five input areas.
Click one of the buttons above to choose which output
you want to see.
When you press one of the arrows,
the output region automatically switches to the 
draft element you just entered.
Note that you can't type into the output area.
</p>
<p>
So what goes into the boxes on the left?
You write little expressions in a custom language
designed for making cool number patterns.
We'll see that language in the next section.
For now, you can just type in a sequence of
numbers (or colors) and then press the arrow.
</p>
<p>
<h3>Important Note</h3> 
If you want to play around with the inputs before
you learn the pattern languages,
try to stick to the following rules.
Your sequences 
for the warp and weft patterns must
be made up only of numbers from 0 to 7, and they must
be separated by spaces (don't use commas
or periods or anything else).
Your sequences for warp and weft colors
must consist only of color names,
separated by spaces 
(for a list of color names, see the section on
<a href="#colors">Colors</a>).
Finally,
the tie-up input should contain just the
two numbers 0 and 1 in whatever sequence you like,
again separated only by spaces.
These rules are just for the moment,
so you can play around with
the inputs before you get to know the pattern language.
</p>

<p><a name='makingPatterns'></a></p>
<h1>Making Patterns: The AWL Language</h1>

<p>
A digital loom lets us create large, complicated patterns
in our draft and see their results almost instantly.
You might think that the best way to do this would be
direct interaction: 
just click on the cells of a draft to turn them on and off.
But when patterns become big (like 50 or 200)
elements long, then modifying them by hand becomes
tedious and error-prone.
</p>
<p>
Instead, we use a pattern-making language.
Rather than typing (or clicking) in your pattern,
you type in a short sequence of instructions
that make the pattern for you.
This makes it fast and easy to experiment with big
changes to your draft,
and to explore possibilities by just experimenting
and following your intuition -
or even just messing around at random!
</p>
<p>
Our pattern-making language is called AWL
(Andrew's Weaving Language).
It's loosely based on an undocumented weaving language
that shipped with early versions of the Painter program.
I modified and extended that program to produce AWL.
</p>
<p>
As we've seen, you create your draft by typing
AWL into an input box.
Then you press the arrow for that box,
which converts your AWL into a sequence of numbers
(or colors),
which are then copied into the loom.
The fabric is then automatically updated.
If you want to see the output sequence for any of the
five boxes,
then after you've entered it and pressed the arrow,
choose the corresponding button in the output area
at the bottom of the left side.
Let's now look at the structure of AWL.
</p>
<p>
AWL is a <em>stack-based</em> language.
The traditional way to think about this
is to picture a <strong>stack</strong>
of cafeteria trays,
sitting one on top of the other.
We can write something on each tray:
a number, a string, a list of numbers,
whatever we decide.
We restrict ourselves to only two
operations on this stack:
we can <strong>push</strong> a new
tray onto the top,
or we can <strong>pop</strong> the
topmost tray off the stack.
That's it.
Of course, if we push a tray we no
longer have it in our hands;
it's on the stack.
And if we pop a tray it's no longer
on the stack,
but it's on our hands where we can
read its value and do something with it.
We'll say that if there are no trays,
we have an <strong>empty stack</strong>
(the thinking is that the stack is still
there in an abstract way,
there's just nothing in it).
We'll make the rule that it's illegal
to try to pop the top tray off an empty
stack (since there are no trays to pop).
</p>
<p>
To add 5 and 3 we usually write <code>5+3</code>.
But in a stack-based language,
we write <code>5 3 +</code>.
Let's read this left to right.
We'll treat this as a string of
<em>words</em>, separated by white space.
There are two kinds of words:
<strong>data</strong> and <strong>commands</strong>.
Basically, anything that isn't a command
is presumed to be data.
</p>
<p>
So let's read <code>5 3 +</code>.
We start with an empty stack.
The first word is <code>5</code>.
That's not a command,
we we push it onto the stack,
which now has just one element,
the number 5.
The next word is <code>3</code>.
That's also not a command, so again
we push it.
Now our stack has two items on it:
the number 5 (on the bottom) 
and the number 3 (on the top).
The next word is <code>+</code>.
Aha, that's a command!
And we know it takes two values:
the left and right side of the 
addition symbol.
Since we want two pieces of data,
we'll pop the stack twice.
The first time we pop it,
we get the number 3, since that
was on top.
By convention, we'll treat that as
the data on the right side of the addition
sign, 
so now we're considering the
result of <em>something</em> plus 3.
We pop the stack again,
getting 5,
and that goes on the left side
of our traditional expression <code>5+3</code>.
Note that the stack is now emptyh.
So we evalute our two pieces of data using
the addition command,
getting the result <code>8</code>.
By convention,
all operators push their results back
onto the stack.
Since the stack was empty once we
popped the 5,
when we push the 8 onto the top of the
stack it's now the only element on the stack.
</p>
<p>
That's the basic idea in a nutshell
(see the
<a href="#furtherReading">Further Reading</a>
section if you crave more details).
The calculator example we gave above is
a famous way to illustrate a stack language.
And it's almost right for AWL,
but with a twist.
Our pieces of data are not number,
but <strong>lists</strong>.
They can be lists of number or lists of
colors, but either way they're always lists.
In AWL, 
a list has to have at least one element
(that is, at least one number or color),
but they can be as long as you like.
In fact, much of the power of AWL is that
you can create very big lists with just a
few commands.
Since our lists get turned into the 
checkerboards of the warp, weft, and tie-up
(and the colors for the warp and weft),
having really long lists with lots of
interesting internal patterns can produce
large visual patterns with tons of interesting
structure and detail.
</p>

<p><a name='concepts'></a></p>
<h2>AWL Concepts</h2>

<p>
AWL commands are also called <strong>operators</strong>,
and the data they use are also called <strong>arguments</strong>.
We call any item on a list an <strong>element</strong>,
so in AWL any element is either a number or a color.
Any command that produces a result automatically
pushes that result onto the stack when it's done.
</p>

<h3>Numbers and Lists</h3>
<p>
AWL lists can be made up of either numbers or colors,
but you can't mix them.
Many commands don't care what kind of list they get.
For example, <code>reverse</code>
simply pops a list off the stack,
reverses the order of its elements,
and pushes the result back on.
You can give <code>reverse</code> a list
of numbers or colors, and it will happilyd
do its job.
</p>
<p>
On the other hand, some commands require
lists of numbers. 
For example,
<code>block</code> takes two lists
(we'll call them <b>A</b> and <b>B</b>).
It makes a new list by repeating each
element of <b>B</b> the number of times
given by the corresponding element of <b>A</b>.
<code><b>A</b>=2 3 4</code>
and
<code><b>B</b>=1 5 8</code>,
the result of block would be
<code>1 1 5 5 5 8 8 8 8</code>.
If <code><b>B</b>=yellow blue red</code>,
the result of block would be
<code>yellow yellow blue blue blue red red red red</code>.
So for the <code>block</code> command,
list <b>A</b> has to contain numbers,
while list <b>B</b> can hold either numbers or colors.
</p>
<p>
The table identifies whether each 
list must be made up of all numbers,
or all colors,
or either.
</p>

<h3>How To Enter Two Lists In A Row</h3>
<p>
To push a list onto the stack,
you just give its values.
So whether your list has one element
(a number or color), or ten of them,
you just name them all.
As always, 
each list item  must be a single string of
characters with no spaces,
and each element must be 
separated from the others with a space.
</p>
<p>
But what if you want to push two lists
in a row?
Many AWL commands take two lists,
so they expect to pop a list off the stack,
and then another.
Suppose your first list is 
<code>1 2 3</code> and your second is <code>9 8 7 6</code>.
If you typed <code>1 2 3 9 8 7 6</code> into
the input box,
you'd be creating one list with seven elements.
The trick is to call <code>push</code>
between one list and another:
<code>1 2 3 push 9 8 7 6</code> does the trick.
Now the stack holds two new elements
(on top of whatever might have been there before):
one entry with the list <code>1 2 3</code>,
and on top of that (and on top of the stack)
is the list <code>9 8 7 6</code>.
Forgetting to push between two lists is a common
mistake.
You'll often see this kind of thing written
<code>1 2 3 / 9 8 7 6</code> because
<code>/</code> is a shortcut for <code>push</code>.
</p>
<p>
This situation is the pretty much the only 
time you'll ever need to explicitly push something
onto the stack,
because
the rest of the time the system manages all the
pushes for you.
In particular, if you name a list and then
follow it with a command name,
the system will automatically push the list
onto the stack for you.
So if we imagine a command named <code>floop</code>
that takes one list as an argument,
<code>1 2 3 floop</code>
is the same as <code>1 2 3 push floop</code>
or <code>1 2 3 / floop</code>.
Since it's good to keep your AWL as simple
as possible (so it's easy to understand and modify),
I suggest leaving out those extraneous push
commands (in my expressions, I always leave them out).
</p>

<h3>Results Get Pushed Automatically</h3>
<p>
Any command that produces a result will push
that result back onto the stack automatically.
If you start providing numbers or colors,
they are presumed to be part of a new list,
and are not tacked on to the end of the
list that was just pushed as the result
of the command.
</p>
<p>
For exmaple, the expression
<code>1 2 3 reverse 4 5</code>
will produce a stack with two elements.
On the bottom is the list <code>3 2 1</code>,
and above it, 
on the top of the stack,
is the list <code>4 5</code>.
</p>

<h3>The Domain</h3>
<p>
When you have 8 threads in your warp
and weft (the starting default),
then your pattern can only contain the
numbers 0 through 7.
This range [0,7] is called the <strong>domain</strong>.
</p>
<p>
The domain is most important when you're using
counting commands.
For example, <code>up</code>
takes two lists as input 
(as usual, we'll call them <b>A</b> and <b>B</b>).
The result of <code>up</code> is the list <b>A</b>,
followed by an ascending list of numbers that starts
with the last value of <b>A</b> and ends at the
first value of <b>B</b>, then the list <b>B</b>.
For example, 
<code>1 2 3 / 6 7 up</code>
will produce
<code>1 2 3 4 5 6 7</code>.
In this example, <code>up</code> is counting
upwards from 3 to 6,
and including all the values in between 
(4 and 5) in the output.
But what should be in response to
<code>3 5 6 / 2 2 up</code>?
The answer is that the program still counts
upward,
but it respects the domain.
When it gets to 8,
which is outside the domain,
that <em>wraps around</em> to the
start of the domain, which is 0,
and the counting continues.
So the result of that expression is
<code>3 5 6 7 0 1 2 2</code>.
</p>
<p>
The same principle applies to counting down.
For example,
<code>3 5 6 / 2 2 down</code>
produces
<code>3 5 6 5 4 3 2 2</code>,
while
<code>2 3 / 6 5 down</code>
produces
<code>2 3 2 1 0 7 6 5</code>,
where <code>down</code> inserted
the short run <code> 2 1 0 7</code>
as it tried to count dowwards from 3 to 6.
</p>
<p>
You can set the two ends of the domain
with the <code>domain</code> command,
allowing you to change it mid-expression.
For example, if your warp has only 4 threads,
you probably want to wrap around your up counts
after 3. 
Consider this expression:
<code>1 2 / 1 2 up</code>.
Using the default domain, 
you'd get back
<code>1 2 3 4 5 6 7 0 1 2</code>.
But if you want to use a domain from 0 to 3,
you'd write
<code>0 / 3 domain 1 2 / 1 2 up</code>,
which would produce
<code>1 2 3 0 1 2</code>.
Keep in mind that your new domain will remain
in effect until you change it again.
Each input box maintains its own domain,
and it always starts out with the range [0,7].
</p>

<h3>Automatic Resizing</h3>

<p>
Some commands require both lists to have
the same length.
For exmaple, we saw above that <code>block</code>
takes two lists, <b>A</b> and <b>B</b>.
It takes the first number in <b>A</b>,
and repeats the first element of <b>B</b> that
many times.
Then it gets the second number in <b>A</b>,
and repeats the second element of <b>B</b> that
many times.
Because the elements of the two lists are
matched up one to one,
both lists need to have the same length,
or the same number of elements.
</p>
<p>
All of the commands that have this requirement
will automatically <em>resize</em> the input
lists for you by repeating the shorter one
as needed until it's as long as the longer
list (if the repeated list gets too long,
we just drop the extraneous elements at the end).
This doesn't change your input lists,
and it all happens under the hood.
But we identify which commands automatically
resize for you,
so you won't have to spend effort doing it yourself.
</p>

<p><a name='commands'></a></p>
<h2>The AWL Commands</h2>

<p>
Here we'll collect all the AWL commands 
together in a big table.
In this table,
the
bold capital letters <b>A</b> and <b>B</b>
stand for lists,
and lower-case letters
<var>c</var> and <var>d</var>
stand for single numbers
(technically, a single number is a list,
but here we mean to indicate that this
list must have only one element).
A0 and AL refer to the first
and last elements of list A (and B0 and BL do the
same for list B).
Ai refers to the i'th element of A,
and Bi is the same for B.
</p>
<p>
The column headings can be interpreted this way:
</p>
<ul>
<li><strong>Command:</strong>  The command name
</li>
<li><strong>Short:</strong> The command's shortcut, if it has one
</li>
<li><strong>List A:</strong>  N if <b>A</b> must be numbers, C if <b>A</b> must be colors
</li>
<li><strong>List B:</strong>  N if <b>B</b> must be numbers, C if <b>B</b> must be colors
</li>
<li><strong>Wrap:</strong> does this command produces numbers that might wrap around the domain
</li>
<li><strong>Resize:</strong>  does this command make both lists the same size by repeating the shorter list
</li>
<li><strong>Summary:</strong> A short description of what the command does
</li>
</ul>

<p>
AWL has a bit more than 40 commands. I won't run through
them all here.
You can find a discussion of each one in Part 2 of my CG&A
Digital Weaving series,
which again you can read for free by going to my
list of
<a href="http://www.glassner.com/computer-graphics/cga-columns/" target="_blank"">my CG&A columns</a>,
or read in 
<a href="http://www.glassner.com/portfolio/morphs-mallards-and-montages/" target="_blank">my book</a>
that collects those columns.
Note that this version of AWL is a bit different than
what's described in those references.
After the table is a summary of the differences.
</p>
<p>
Remember that the first thing popped off the stack is the
most recent thing pushed.
So for example, the commmand summarized
<code><b>A</b> <b>B</b> <var>c</va> ramploop</code>
expects three elements on the stack:
on top (and most recently pushed) is the number <var>c</var>,
under it (and pushed just before <var>c</var>) is the list <b>B</b>,
and on the bottom (and first thing pushed in this group) is the list <b>A</b>.
</p>


<table id="awlsummary" class="table table-striped table-bordered table-condensed">
	<thead>
		<tr>
			<th>Command</th>
			<th>Short</th>
			<th>List <b>A</b></th>
			<th>List <b>B</b></th>
			<th>Wrap</th>
			<th>Resize</th>
			<th>Summary</th>
		</tr>
	</thead>
	<tbody>

<tr>
	<td><b>A</b> binary0</td>
	<td>b0</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Treat <b>A</b> as alternating runs of 0s and 1s</td>
</tr>
<tr>
	<td><b>A</b> binary1</td>
	<td>b1</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Treat <b>A</b> as alternating runs of 1s and 0s</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> block</td>
	<td>#</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>Each <b>A</b>i is repeated <b>B</b>i times</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> blockpal</td>
	<td>#p</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>block with internal palindrome</td>
</tr>
<tr>
	<td>clear</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Erase the stack</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> concat</td>
	<td>,</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Concatenate the top two stack elements</td>
</tr>
<tr>
	<td><var>c</var> <var>d</var> domain</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Set the domain to [<var>c</var>, <var>d</var>]</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> down</td>
	<td>&gt;</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td> </td>
	<td><b>A</b>, descending run from <b>A</b>L to <b>B</b>0, <b>B</b></td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> <var>c</var> downloop</td>
	<td>&gt;l</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td> </td>
	<td>Like down, but includes <var>c</var> runs as well</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> downup</td>
	<td>&gt;u</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>Y*</td>
	<td>Alternating down and up runs (<strong>A</strong> may be 1 longer than <strong>B</strong)
</tr>
<tr>
	<td><b>A</b> <b>B</b> <var>c</var> downuploop</td>
	<td>&gt;ul</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>Y*</td>
	<td>Like downup but include <var>c</var> runs as well</td>
</tr>
<tr>
	<td><b>A</b> dup</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Pop the top of the stack and push it back twice</td>
</tr>
<tr>
	<td><strong>A</strong> <var>d</var> extend</td>
	<td>+</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>repeat or clip <b>A</b> to <var>d</var> elements</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> growblock</td>
	<td>=</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>Interleave <b>A</b> with growing palindromes of <b>B</b></td>
</tr>
<tr>
	<td><b>A</b> iblock</td>
	<td>i#</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>Like block but the inputs are interleaved in <b>A</b></td>
</tr>
<tr>
	<td><b>A</b> iblockpal</td>
	<td>i#p</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>iblock with internal palindrome</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> interleave</td>
	<td>%</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>Take alternating elements of <b>A</b> and <b>B</b></td>
</tr>
<tr>
	<td><b>A</b> <var>d</var> nth</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Take every <var>d</var>'th element of <b>A</b></td>
</tr>
<tr>
	<td><b>A</b> palindrome</td>
	<td>|</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td><b>A</b> followed by its near reversal</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> pbox</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Shortcut for <b> A B A </b> veclen extend permute</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> permute</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Use elements of <b>B</b> to index <b>A</b></td>
</tr>
<tr>
	<td><b>A</b> pop</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Discard top of the stack</td>
</tr>
<tr>
	<td>push</td>
	<td>/</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Consider all since last command a single list</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> ramp</td>
	<td>-</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td> </td>
   <td><b>A</b>, up or down as needed to stay in domain, <b>B</b></td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> <var>c</var> ramploop</td>
	<td>-l</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td> </td>
	<td>Like ramp but include <var>c</var> runs as well</td>
</tr>
<tr>
	<td><b>A</b> <var>d</var> repeat</td>
	<td>*</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>repeat <b>A</b> a total of <var>d</var> times</td>
</tr>
<tr>
	<td><strong>A</strong> reverse</td>
	<td>@</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>reverse the elements of <strong>A</strong></td>
</tr>
<tr>
	<td><b>A</b> <var>d</var> rotatel</td>
	<td><<</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>rotate <b>A</b> left by <var>d</var> steps</td>
</tr>
<tr>
	<td><b>A</b> <var>d</var> rotater</td>
	<td>>></td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>rotate <b>A</b> right by <var>d</var> steps</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> swap</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Exchange the top two stack elements</td>
</tr>
<tr>
	<td><b>A</b> <var>d</var> stencil</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td><var>d>1</var>: skip <b>A</b>0, keep the next <var>d-1</var> entries, skip the next, repeat</td>
</tr>
<tr>
	<td><b>A</b> tartan</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>Like iblock but repeats are half length</td>
</tr>
<tr>
	<td><b>A</b> tartanpal</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>tartan with internal palindrome</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> template</td>
	<td>:</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Create a subarticulation using <b>B</b> as a template</td>
</tr>
<tr>
	<td><b>A</b> <var>c</var> <var>d</var> twilll</td>
	<td>t&lt;&lt;</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Rotate left by <var>c</var> steps, <var>d</var> times</td>
</tr>
<tr>
	<td><b>A</b> <var>c</var> <var>d</var> twillr</td>
	<td>t&gt;&gt;</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Rotate right by <var>c</var> steps, <var>d</var> times</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> up</td>
	<td>&lt;</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td> </td>
	<td><b>A</b>, ascending run from <b>A</b>L to <b>B</b>0, <b>B</b></td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> updown</td>
	<td>&lt;d</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>Y*</td>
	<td>Alternating up and down runs (<strong>A</strong> may be 1 longer than <strong>B</strong)
</tr>
<tr>
	<td><b>A</b> <b>B</b> <var>c</var> updownloop</td>
	<td>&lt;dl</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td>Y*</td>
	<td>Like updown but include <var>c</var> runs as well</td>
</tr>
<tr>
	<td><b>A</b> <b>B</b> <var>c</var> uploop</td>
	<td>&lt;l</td>
	<td> </td>
	<td> </td>
	<td>Y</td>
	<td> </td>
	<td>Like up, but includes <var>c</var> runs as well</td>
</tr>
<tr>
	<td><b>A</b> veclen</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Push <b>A</b> back ont the stack, then the length of <b>A</b></td>
</tr>
<tr>
	<td><b>A</b> vmax</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Push <b>A</b> back ont the stack, then the largest element in <b>A</b></td>
</tr>
<tr>
	<td><b>A</b> vmin</td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td> </td>
	<td>Push <b>A</b> back ont the stack, then the smallest element in <b>A</b></td>
</tr>
    </tbody>
  </table>



<p><a name='notes'></a></p>
<h2>Notes on This Version of AWL</h2>

<p>
Here are the key differences between what's in 
<a href="http://www.glassner.com/computer-graphics/cga-columns/" target="_blank"">my CG&A columns</a>
and
<a href="http://www.glassner.com/portfolio/morphs-mallards-and-montages/" target="_blank">my book</a>,
and what's implemented here.
</p>

<ul>
<li><strong>template:</strong> Templates are no longer automatically made relative to the
first number in the second list. So the values you add to each
number in your starting list are simply the numbers you provide.
For example, <code>3 4 : 1 2 3</code> will add the values <code>1 2 3</code>
to <code>3</code> and then to <code>4</code>, producing <code>4 5 6 5 6 7</code>.</li>
<li><strong>updown, updownloop, downup, downuploop:</strong> These four
commands normally reshape the two input lists so they have the same size.
Introduced to the online version, this resizing won't happen if
the first list can have 1 more element than the second one. This way
you can make nice repeating patterns of up and down ramps.
For example, <code>0 1 / 4 updown</code> has two elements in the first
list (<code>0 1</code>)and only one in the second (<code>7</code>).
These lists won't be resized, so the result goes up from <code>0</code>
to <code>4</code>, then back down to <code>1</code>,
giving you the nice up-down sequence <code>0 1 2 3 4 3 2 1</code>.
When this automatically repeats you'll get a nice triangle wave 
repeating forever (a perfect starting point for twills).</li>
<li><strong>twillr, twilll:</strong> These commands got a little 
confused. Here's how they work now.
<ol>
<li>
I implemented them backwards in the original code,
so they rotated in the directions opposite to their names.
That's fixed now (and the examples have been updated
to reflect that).</li>
<li>
Both commands take as input a list <code>A</code>
and two numbers
<code>c</code>
and 
<code>d</code>,
in that order.
The list gets repeated <code>d</code> times.
The first time it appears just as given.
The second time it's rotated right (or left) by <code>c</code>
steps.
The next time that most recent version gets rotated right
(or left) by another <code>c</code> steps, and so on.
So for example,
<code>0 1 2 3 / 1 / 4 twillr</code>
will produce the list
<code>0 1 2 3</code>,
then it gets rotated right once to produce
<code>3 0 1 2</code>,
then rotated again to make
<code>2 3 0 1</code>,
and then a fourth time to produce
<code>1 2 3 0</code>,
giving a final result of
<code>0 1 2 3 3 0 1 2 2 3 0 1 1 2 3 0</code>.
</li>
<li>The domain minimum is set to 0 if you try to make it negative.
The domain maximum is always 1 more than the minimum.</li>
<li>When the warp and weft patterns are copied to the draft,
any values less than 0 are set to 0.</li>
<li>The <code>stencil</code> command is new.</li>
</ol>
</li>
</ul>

<p>
Here are some helpful hints to keep in mind.
</p>

<ul>
<li>AWL expressions can get complicated very quickly if you let them.
Start simple, and add small bits of complexity one step at a time.</li>
<li>The output window will always show you what's left on top of the stack
when your expression has been evaluated. </li>
<li>A good way to experiment with AWL commands and get a feeling for them
is to ignore the loom and the fabric. Just write little expressions in one
of the input windows and press the arrow,
and see what it generates by looking at the output window below.
</li>
<li>Remember to push between lists! This is an easy thing to forget.</li>
<li>Make sure to keep track of your domain. It starts at [0,7] for both warp and
weft. If you change it, that change stays in effect for the rest of that
expression. You can always set it back to [0,7] if you want.
<li>Make sure you have the tie-up sizes set the way you like. The tie-up doesn't
automatically re-size to fit your warp or weft (that would make it much harder
to experiment with your drafts).</li>
<li>When in doubt, just type in your pattern explicitly;
not everything has to be a clever AWL construction.
For example, if you want the pattern <code>0 1 3 5 2</code>,
it's probably easiest to just type that directly into the text area
and move on.
This is particularly useful for colors,
where the lists are frequently just a single color.
</li>
</ul>

<p><a name='interface'></a></p>
<h2>The Rest of the Interface</h2>

Here's what the rest of the controls do.

<h3>Fabric and Tie-up Size</h3>
<p>
Just above the fabric there are three boxes for you to type in numbers.
</p>
<ul>
<li><strong>Fabric size:</strong> The fabric is always a square. This tells
the program how big that square should be. The warp and weft patterns and
colors are simply repeated as necessary to match the fabric's size.
</li>
<li><strong>Tie-up width:</strong> </li>
<li><strong>Tie-up height:</strong> You can make the tie-up any size you
like, as long as each dimension is at least 2 units.
The data in the tie-up AWL input is used to fill in the grid
starting at the top left and going right,
then down a row and repeating left to right,
and so on.
If there's more data in the tie-up pattern than is needed,
the extra is just ignored.
If the tie-up pattern isn't long enough to fill up the grid,
it's repeated as needed.
</ul>

<h3>Saving and Loading</h3>

<h4>Saving The Fabric</h4>

<p>
To save the image of the fabric,
just right-click on it.
You should get a pop-up menu that
offers you a few options.
One of these will be <em>Save Image As...</em>
(or something close to that).
Choose that,
and you'll get a standard dialog box
letting you put the image where you want it.
The image is saved in the standard PNG format,
which offers the highest quality.
You can change that to JPG or anything else
using almost any image editing program.
</p>

<h4>Saving and Loading The Draft</h4>

<p>
To save your draft,
give it a name by typing
in the text box at the very 
top of the window,
and then press the <strong>Save</strong> button.
</p>
<p>
Note that you will <em>not</em> get a file
dialog box!
So where does your draft go?
It goes into some private storage that's controlled
by the browser.
The downsides of this technique are that this storage
is per-browser,
so for exmaple if you use the program in Firefox and 
save a bunch of drafts,
they'll be visible to Firefox,
but not to Chrome or Safari.
Each of these browsers will have its own private
collection of drafts, and you can't share them
between browsers or even with other people.
I know this is pretty lousy,
but all browsers are
<em>deliberately</em> prevented from talking to
your computer's local disk.
So this is the best solution I could come up with.
See the FAQ for more technical details.
<p>


<p>
To load a draft, click on the <strong>Load Draft:</strong>
button.
You'll see a list with two parts.
The top part lists all of the drafts you've saved using
this browser (the list will vary for each browser,
as discussed above).
Under that, you'll see a list about 25 presets,
or demos.
</p>

<p>
Finally, you can delete a draft from your local
storage by choosing it with the <strong>Load Draft:</strong>
button (or just typing its name into the draft name box)
and then pressing the <strong>Delete</strong> button.
</p>

<p>
Note that you can save new copies of the built-in presets,
using even the very same names.
The system always looks for your personal drafts before
it looks at the presets, so if you use the same name as a
preset you'll always get your version.
You can't delete the presets.
</p>

<p><a name="colors"></a></p>
<h2>Colors</h2>

<p>
You can name your colors in three ways,
and you can even mix and match these in a
single expression.
</p>

<h4>By Name</h4>
<p>
This is probably the easiest option. The Digital Loom
knows 1282 different color names,
gathered from a wide variety of sources.
Probably any color name you know is in the list.
You can browse the colors visually TK By Name TK or 
TK visually grouped bhy color TK.
Note that some colors have multiple names.
I've retained all these names because some might
be more familiar to you than others.
</p>
<p>
For example, a nice middle brown is
<code>HarvestGold</code>.
While some names may include parentheses
or dashes, make sure that your color name
is a single word with <em>no spaces</em>.
If you accidentally type a space,
AWL will read it as two separate
colors in a row to build a pattern
(and it probably won't find both,
of those words in the list of colors;
it usually won't even find one of them).

<h4>By Hex</h4>
<p>
If you're familiar with the hex notation used by
browsers and some drawing programs,
you can use that.
Simply start your color with a hash mark (#)
and follow it with six hex digits
(the numbers 0 to 9, and the letters a to f or A to F).
Remember there cannot be a space between the
hash mark and the hex digits.
The color Harvest Gold can be named
in hex as <code>#DA9100</code>
(case doesn't matter, so <code>#da9100</code>
works just as well).
</p>

<h4>By RGB</h4>
<p>
You can also name your colors using red,
green, and blue values from 0 to 255.
Start with the string <code>rgb(</code>
and then list your values in the order
red, green, blue, separated by commas,
ending with a closing parentheses.
In this form, Harvest Gold would be
written <code>rgb(217,145,0)</code>.
Remember, as always, there can be 
<em>no spaces</em> anywhere in this 
string (not even after the commas).
</p>

<p><a name="faq"></a></p>
<h2>FAQ</h2>

<h3>The table is way too cryptic. What do these commands do?</h3>
<p>
The table is just a quick reference.
You can find a description of each 
command in Part 2 of my 3-part column
on Digital Weaving.
You can find an online PDF in my big list of
<a href="http://www.glassner.com/computer-graphics/cga-columns/" target="_blank"">my CG&A columns</a>.
You can also find those columns,
collected and revised, in my book
<a href="http://www.glassner.com/portfolio/morphs-mallards-and-montages/" target="_blank">Morphs, 
Mallards, and Montages</a>
If you prefer to learn by doing,
try experimenting.
Just type in stuff and see what comes out.

<h3>How do I share my drafts?</strong></h3>
<p>
Right now, it's a hassle (other questions here go into the reasons).
As I discussed in the section on saving your draft,
your files go into a special file that's maintained by the
browser, and you can't get at it.
This is scheduled to change someday soon,
and you'll be able to save and open files from your
local disk as usual (though with some restrictions).
Until that day arrives,
here's the best way to save a draft so you can share 
it with someone else.
Open a text editor and make a new, blank file.
Copy the following eight lines and paste them
into your text editor.
It wouldn't hurt to enter a few blank lines
after each of these.
</p>

<ul>
<li>Warp Pattern:</li>
<li>Weft Pattern:</li>
<li>Warp Colors:</li>
<li>Weft Colors:</li>
<li>Tie-Up:</li>
<li>Fabric Size:</li>
<li>Tie-up Width:</li>
<li>Tie-up Height:</li>
</ul>

<p>
Now click in your browser,
click on the "Warp Pattern" button just above the output area,
copy the text in the output box,
and paste that into the your file
under "Warp Pattern:".
Repeat this for the four other input areas.
Then type into your text file the current
values for the fabric size, tie-up width, and tie-up height.
</p>
<p>
Now you have a file with the AWL that
completely describes your draft.
Save the file from your text editor.
Since that's a normal text file, you can copy it or
back it up or share it or do whatever you like with it.
You can even give it to someone with a real loom,
and they'll be able to weave your fabric!
(Actually, they'd probably prefer a file in the
standard weaving format known as WIF;
see the question on WIF below).
</p>
<p>
Unfortunately, 
the program can't read that file,
so for you or your friends
to get the information back into the Digital Loom
you need to reverse the process.
Open the file in a text editor,
then work one field at a time,
copying the text from the text file (just the AWL expressions,
not your labels - those are just there so you know which is which)
and paste that text into the text boxes
(remember to press the corresponding arrow after each paste).
Then set the tie-up sizes and fabric size if necessary.
Remember you need to press the arrow button to the right
of <em>each</em> input field to 
tell the Digital Loom to read the new AWL you just pasted in.
</p>
<p>
If you want to save the patterns produced by your AWL,
for example to use on a real loom,
you'd follow the same business about creating
a new text file,
and copying data out of the web page and pasting
it into the text file,
only you'd copy the <em>output</em> fields instead.
Those hold the pattern data that you'd then use to
set up a real, physical loom to weave your design.
</p>
<he>Why is all this file stuff so awkward?</h3>
<p>
Actually, it's kind of remarkable that we can manage to save and recall anything at all.
The reasons are technical. If you're into that, read on.
If not, just know that someday things ought to get less weird,
but right now this is all we've got.
</p>
<p>
Browsers are very deliberately designed to be unable to talk to your local computer's
hard drive (this is to protect you, and it's one of the reasons the web has succeeded
the way it has). But there are a few little loopholes to that policy. For example, you
probably know about cookies: these are tiny files on your hard drive, written and read
by the browser, that save preferences and other information for web pages. That's an
example of the browser reading from, and writing to, your computer's hard drive.
The Digital Loom doesn't use cookies, but it uses the other two possible exceptions
(these are both perfectly safe: they're part of the offical, international standards 
that all browsers follow in order to work on the web).
</p>
<p>
The first one lets you save your fabric by right-clicking on it and saving it as a picture.
We manage that by telling the browser that the drawing we made is just a normal photograph 
that can be saved in that usual way.
</p>
<p>
The second trick is called LocalStorage, and that's where we store your drafts.
But this is a very constrained way to save things. Each URL (that is, each web page)
can save up to 5MB total, without exception (that's not enough for pictures!).
And each browser manages its own LocalStorage, so the drafts you save on Firefox,
say, will not be available in Chrome, and vice-versa. This is true for each type
of browser. The files are saved to your hard drive, so if you're using a friend's
computer, your saved files will not be there. Finally, these aren't really files at
all, so don't go looking for them on your disk. They're actually saved inside a
database managed by the browser (that's why we can't use this method to save files
you can share with other people (that's why we can't use this method to save files
you can share with other people)).
</p>

<h3>Can I save my draft in the WIF weaving-file format to share with other weavers, or use to set up a real loom?</h3>
<p>
Oh, how I wish the answer was "yes", but it's not. In fact, I have written all
the code to support reading and writing WIF files.
But that's useless now,
because browsers are forbidden from writing files to your
local file system. 
This means the browser can't write a WIF file to your disk.
There are a few ways to save files, but all the ones I know of have major drawbacks:
you can run a local server, but that's a technical task that most people are not prepared to do;
you can use a commercial remote server, but that means either you or I pay money to buy space;
or
you can use a free remote server, but all the ones I've looked into require a prohibitive amount
of time and work from me to support.
When browsers finally allow us to read and write to 
carefully blocked-off parts of your local file system,
as the current international spec calls upon them to do,
then I'll very happily change the draft saving and loading 
to use WIF files by defaultt.
</p>

<he>Why am I getting a really weird error when my AWL looks fine?</h3>
<p>
A very frequent cause of weird errors is messing up the spacing rule.
Remember that each <em>word</em> in AWL must be surrounded by space.
That means each number and each command.
For example, the shortcut for <code>twillr</code> is <code>t>></code>,
all one word with no spaces.
And if you want to concatenate three lists together,
you'd write <code>, , ,</code> with a space between each comma.
Leaving out those spaces, or including extra ones where they don't belong,
is an easy mistake to make.
</p>


<h3>How do I debug my AWL?</h3>
<p>
If things are going wrong, I find it easiest to write down the whole
expression I'm working on, and then build it up again one step at a time.
Type in one new piece of stuff to build the pattern, hit the button,
and see what's on top of the stack. If that looks right, continue.
If it doesn't, tune up what you have there until it does.
</p>

<h3>You said there should be just one thing left on the stack at the end, but I have more. Is that a problem?</h3>
<p>
Not necessarily, if what's on top is the result you want. But usually that indicates a problem. A common cause of this comes from building up your expression in pieces, but then forgetting to concatenate them together into one big pattern when you're done. A lot of complicated expressions end with a bunch of commas (the concatenation shortcut) to glue together all the intermediate results sitting on the stack.
</p>

<h3>AWL isn't much of a language. Where are the variables, loops, procedures, etc.?</h3>
<p>
AWL isn't a general-purpose programming language, and it doesn't need all that stuff.
It's been designed for one thing only: to help you make cool patterns of numbers
and colors that are useful in weaving. You don't need variables, loops, and all that
stuff to do that.
If you find yourself wanting to use all of those tools to make your expressions,
your best bet is to fire up your favorite language and write programs in it.
The output should be either a big list of numbers or colors,
which you can just copy and paste into the appropriate input box.
Hit the arrow and it will simply copy over into the output box.
Or, if you're feeling fancy, you can use your program to write AWL expressions
that you copy and paste the same way.
</p>

<h3>It still seems pretty weak. You don't even have addition or subtraction!</h3>
<p>
AWL was designed to make patterns,
not to calculate with numbers.
If you find yourself really needing addition and subtraction,
you can fake them with the <code>template</code> command.
</p>

<h3>Hey! You crashed my browser!</h3>
<p>Sorry! 
The truth is that there are a lot of ways that things can go
wrong when we turn your AWL into a pattern.
I've tried to catch all of them,
and to give you at least some information about where things
went wrong.
If something slipped past me and crashed your browser,
I'd love to fix it.
The catch is that I'd need the <em>exact</em> AWL expression you
were trying to translate at the time of the crash,
and that's probably gone because,
well,
the browser's crashed.
So if you can,
try to immediately re-load the page and recreate the problem.
Copy the text in your input box frequently each time you get
closer to the problem.
Then when it does crash,
you'll be able to send me email and simply paste the
offending AWL right into the body of the mail.
</p>

<p><a name="furtherReading"></a></p>
<h2>Further Reading</h2>
<p>
TK stuff goes here
</p>

			</div> <!-- column 10 -->
		</div> <!-- row -->
	</div> <!-- container -->

</body>
</html>

